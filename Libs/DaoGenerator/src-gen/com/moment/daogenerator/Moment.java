package com.moment.daogenerator;

import com.moment.daogenerator.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table moments.
 */
public class Moment {

    private Long id;
    private Integer state;
    private Integer guestNumber;
    private Integer guestComing;
    private Integer guestNotComing;
    private Integer privacy;
    private String name;
    private String description;
    private String placeInformations;
    private String infoTransport;
    private String hashtag;
    private String adresse;
    private String keyBitmap;
    private String urlCover;
    private java.util.Date dateDebut;
    private java.util.Date dateFin;
    private Boolean isOpenInvit;
    private long userId;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient MomentDao myDao;

    private User user;
    private Long user__resolvedKey;


    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public Moment() {
    }

    public Moment(Long id) {
        this.id = id;
    }

    public Moment(Long id, Integer state, Integer guestNumber, Integer guestComing, Integer guestNotComing, Integer privacy, String name, String description, String placeInformations, String infoTransport, String hashtag, String adresse, String keyBitmap, String urlCover, java.util.Date dateDebut, java.util.Date dateFin, Boolean isOpenInvit, long userId) {
        this.id = id;
        this.state = state;
        this.guestNumber = guestNumber;
        this.guestComing = guestComing;
        this.guestNotComing = guestNotComing;
        this.privacy = privacy;
        this.name = name;
        this.description = description;
        this.placeInformations = placeInformations;
        this.infoTransport = infoTransport;
        this.hashtag = hashtag;
        this.adresse = adresse;
        this.keyBitmap = keyBitmap;
        this.urlCover = urlCover;
        this.dateDebut = dateDebut;
        this.dateFin = dateFin;
        this.isOpenInvit = isOpenInvit;
        this.userId = userId;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getMomentDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public Integer getState() {
        return state;
    }

    public void setState(Integer state) {
        this.state = state;
    }

    public Integer getGuestNumber() {
        return guestNumber;
    }

    public void setGuestNumber(Integer guestNumber) {
        this.guestNumber = guestNumber;
    }

    public Integer getGuestComing() {
        return guestComing;
    }

    public void setGuestComing(Integer guestComing) {
        this.guestComing = guestComing;
    }

    public Integer getGuestNotComing() {
        return guestNotComing;
    }

    public void setGuestNotComing(Integer guestNotComing) {
        this.guestNotComing = guestNotComing;
    }

    public Integer getPrivacy() {
        return privacy;
    }

    public void setPrivacy(Integer privacy) {
        this.privacy = privacy;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getPlaceInformations() {
        return placeInformations;
    }

    public void setPlaceInformations(String placeInformations) {
        this.placeInformations = placeInformations;
    }

    public String getInfoTransport() {
        return infoTransport;
    }

    public void setInfoTransport(String infoTransport) {
        this.infoTransport = infoTransport;
    }

    public String getHashtag() {
        return hashtag;
    }

    public void setHashtag(String hashtag) {
        this.hashtag = hashtag;
    }

    public String getAdresse() {
        return adresse;
    }

    public void setAdresse(String adresse) {
        this.adresse = adresse;
    }

    public String getKeyBitmap() {
        return keyBitmap;
    }

    public void setKeyBitmap(String keyBitmap) {
        this.keyBitmap = keyBitmap;
    }

    public String getUrlCover() {
        return urlCover;
    }

    public void setUrlCover(String urlCover) {
        this.urlCover = urlCover;
    }

    public java.util.Date getDateDebut() {
        return dateDebut;
    }

    public void setDateDebut(java.util.Date dateDebut) {
        this.dateDebut = dateDebut;
    }

    public java.util.Date getDateFin() {
        return dateFin;
    }

    public void setDateFin(java.util.Date dateFin) {
        this.dateFin = dateFin;
    }

    public Boolean getIsOpenInvit() {
        return isOpenInvit;
    }

    public void setIsOpenInvit(Boolean isOpenInvit) {
        this.isOpenInvit = isOpenInvit;
    }

    public long getUserId() {
        return userId;
    }

    public void setUserId(long userId) {
        this.userId = userId;
    }

    /** To-one relationship, resolved on first access. */
    public User getUser() {
        long __key = this.userId;
        if (user__resolvedKey == null || !user__resolvedKey.equals(__key)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            UserDao targetDao = daoSession.getUserDao();
            User userNew = targetDao.load(__key);
            synchronized (this) {
                user = userNew;
            	user__resolvedKey = __key;
            }
        }
        return user;
    }

    public void setUser(User user) {
        if (user == null) {
            throw new DaoException("To-one property 'userId' has not-null constraint; cannot set to-one to null");
        }
        synchronized (this) {
            this.user = user;
            userId = user.getId();
            user__resolvedKey = userId;
        }
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    // KEEP METHODS END

}
